<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>艾伦的空间 - network</title>
    <subtitle>技术闲谈</subtitle>
    <link rel="self" type="application/atom+xml" href="/tags/network/atom.xml"/>
    <link rel="alternate" type="text/html" href="/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2022-01-03T21:08:00+08:00</updated>
    <id>/tags/network/atom.xml</id>
    <entry xml:lang="en">
        <title>Rust异步网络IO</title>
        <published>2022-01-03T21:08:00+08:00</published>
        <updated>2022-01-03T21:08:00+08:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="/posts/rust-async-io/"/>
        <id>/posts/rust-async-io/</id>
        
        <content type="html" xml:base="/posts/rust-async-io/">&lt;p&gt;同步 I&#x2F;O 模型可能是在给定时间内处理多个客户端的主要瓶颈，必须使用线程处理更多的客户端。为更好的方法来扩展，我们可以让套接字是非阻塞的，而不是应对套接字的阻塞性质。&lt;&#x2F;p&gt;
&lt;p&gt;对于非阻塞套接字，其上的任何读取、写入或者操作都会立刻返回，无论操作成功与否。没有客户端需要等待请求完成，而是稍后同志请求成功与否。与线程相比，异步 I&#x2F;O 模型非常高效，但它增加了代码的复杂性。&lt;&#x2F;p&gt;
&lt;p&gt;在基于 UNIX 的平台上，套接字上的轮询机制是通过 poll 和 select 系统调用完成的。这些调用在所有 UNIX 操作系统上都是兼容的，除此之外，Linux 还支持 epoll API。在 poll 和 select 对每个请求的套接字运行 for 循环的情况下，epoll 通过运行时 &lt;code&gt;O(1)&lt;&#x2F;code&gt;来同志用户的套接字事件。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-zhong-de-yi-bu-chou-xiang&quot;&gt;Rust 中的异步抽象&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 提供了第三方软件包形式的便捷抽象，用于处理异步 I&#x2F;O。当处理非阻塞套接字和底层套接字轮询机制时，它为开发人员简化了大多数复杂状态机的处理。可供用户选择的两个底层抽象软件包是 &lt;code&gt;futures&lt;&#x2F;code&gt; 和 &lt;code&gt;mio&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mio&quot;&gt;mio&lt;&#x2F;h3&gt;
&lt;p&gt;mio 提供了底层机制的高度抽象，他可以为大多数 IO 复用 API 提供跨平台、高效的接口。mio 是一款底层软件包，它提供了一种为 socket 事件设置反应器的便捷方法。它和标准库类型相似，例如 &lt;code&gt;TcpStream&lt;&#x2F;code&gt;类型，不过默认情况下它是非阻塞的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;futures&quot;&gt;futures&lt;&#x2F;h3&gt;
&lt;p&gt;mio 杂耍式的套接字轮询状态机用起来并不是很方便。为了提供可供应用程序开发人员使用的高级 AP，提供了 future 软件包。&lt;&#x2F;p&gt;
&lt;p&gt;futures 软件包提供了一个 &lt;code&gt;Future&lt;&#x2F;code&gt; 核心 trait，这是该软件包的核心组成部分。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Future {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Future将解析的值
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Item;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 操作失败时的错误类型
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Error;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; poll 指定了应该如何完成future过程
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;poll&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Poll&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Item, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Error&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Future&lt;&#x2F;code&gt; 值自身不能构建异步应用程序，你需要将某种反应器和事件循环来推进 future 完成。&lt;code&gt;poll&lt;&#x2F;code&gt; 函数指定了应该如何完成 future 过程。future 也可以由几件事情组合而成，从而一个接一个地链接起来。为了推进 future，我们需要一个反应器和事件循环实现，这是由 tokio 软件包提供。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tokio&quot;&gt;tokio&lt;&#x2F;h3&gt;
&lt;p&gt;tokio 整合了上述两种抽象，以及工作窃取调度程序、事件循环和计时器实现，它提供了一个运行时来驱动 future 完成。通过 tokio 框架，你可以生成多个 future 并让它们同时运行。&lt;&#x2F;p&gt;
&lt;p&gt;tokio 软件包在技术上是一种运行时，由一个线程池、事件循环，基于 mio 的 I&#x2F;O 事件的反应器组成。&lt;&#x2F;p&gt;
&lt;p&gt;当 future 没有任何数据要解析，或者在 &lt;code&gt;TcpStream&lt;&#x2F;code&gt; 客户端读取正在等待到达套接字的数据时，它将返回 NoReady 状态。但是在执行此操作时，还需要向反应器注册感兴趣的内容，以便能够再次获知服务器的任何新数据。&lt;&#x2F;p&gt;
&lt;p&gt;当创建 future 时，无须执行任何其他操作。对于 future 定义的工作任务，必须提交给执行程序完成。在 tokio 中，任务是可以执行 future 的用户级线程。在 poll 方法的实现中，任务必须安排自己稍后执行轮询，以防相关工作停滞。为此，它必须将其任务处理程序传递给反应器线程。在 Linux 中，反应器是 mio 软件包。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gou-jian-yi-bu-redis-fu-wu-qi&quot;&gt;构建异步 Redis 服务器&lt;&#x2F;h3&gt;
&lt;p&gt;略&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
